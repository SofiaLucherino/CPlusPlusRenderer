{
	"nodes":[
		{"id":"a56b188a23ce71a7","type":"text","text":"\t#if 0\n\t\tVertex0.Pos.w = 1.0f / Vertex0.Pos.w;\n\t\tVertex1.Pos.w = 1.0f / Vertex1.Pos.w;\n\t\tVertex2.Pos.w = 1.0f / Vertex2.Pos.w;\n\n\t\tVertex0.Pos.xyz *= Vertex0.Pos.w;\n\t\tVertex1.Pos.xyz *= Vertex1.Pos.w;\n\t\tVertex2.Pos.xyz *= Vertex2.Pos.w;\n\n\t\tv2 PointA = NdcToPixels(Vertex0.Pos.xy);\n\t\tv2 PointB = NdcToPixels(Vertex1.Pos.xy);\n\t\tv2 PointC = NdcToPixels(Vertex2.Pos.xy);\n\n\t\ti32 MinX = min(min((i32)PointA.x, (i32)PointB.x), (i32)PointC.x);\n\t\ti32 MinY = min(min((i32)PointA.y, (i32)PointB.y), (i32)PointC.y);\n\n\t\ti32 MaxX = max(max((i32)round(PointA.x), (i32)round(PointB.x)), (i32)round(PointC.x));\n\t\ti32 MaxY = max(max((i32)round(PointA.y), (i32)round(PointB.y)), (i32)round(PointC.y));\n\t\n\t\t#if 0\n\t\t\tMinX = max(0, MinX);\n\t\t\tMinX = min(MinX, GlobalState.FrameBufferWidth - 1);\n\n\t\t\tMinY = max(0, MinY);\n\t\t\tMinY = min(MinY, GlobalState.FrameBufferHeight - 1);\n\n\t\t\tMaxX = max(0, MaxX);\n\t\t\tMaxX = min(MaxX, GlobalState.FrameBufferWidth - 1);\n\n\t\t\tMaxY = max(0, MaxY);\n\t\t\tMaxY = min(MaxY, GlobalState.FrameBufferHeight - 1);\n\t\t#endif\n\n\t\tv2 Edge0 = PointB - PointA;\n\t\tv2 Edge1 = PointC - PointB;\n\t\tv2 Edge2 = PointA - PointC;\n\n\t\tb32 isTopLeft0 = (Edge0.y > 0 || Edge0.x > 0.0f && Edge0.y == 0.0f);\n\t\tb32 isTopLeft1 = (Edge1.y > 0 || Edge1.x > 0.0f && Edge1.y == 0.0f);\n\t\tb32 isTopLeft2 = (Edge2.y > 0 || Edge2.x > 0.0f && Edge2.y == 0.0f);\n\n\t\tf32 BaryCentricDiv = CrossProduct2d(PointB - PointA, PointC - PointA);\n\n\t\tVertex0.UV *= Vertex0.Pos.w;\n\t\tVertex1.UV *= Vertex1.Pos.w;\n\t\tVertex2.UV *= Vertex2.Pos.w;\n\n\t\tf32 Edge0DiffX = Edge0.y;\n\t\tf32 Edge0DiffY = -Edge0.x;\n\t\tf32 Edge1DiffX = Edge1.y;\n\t\tf32 Edge1DiffY = -Edge1.x;\n\t\tf32 Edge2DiffX = Edge2.y;\n\t\tf32 Edge2DiffY = -Edge2.x;\n\n\t\tv2 StartPos = V2(MinX, MinY) + V2(0.5f, 0.5f);\n\n\t\tf32 Edge0RowY = CrossProduct2d(StartPos - PointA, Edge0);\n\t\tf32 Edge1RowY = CrossProduct2d(StartPos - PointB, Edge1);\n\t\tf32 Edge2RowY = CrossProduct2d(StartPos - PointC, Edge2);\n\n\n\t\tfor (int Y = { MinY }; Y <= MaxY; ++Y)\n\t\t{\n\t\t\tf32 Edge0 = Edge0RowY;\n\t\t\tf32 Edge1 = Edge1RowY;\n\t\t\tf32 Edge2 = Edge2RowY;\n\n\t\t\tfor (int X = { MinX }; X <= MaxX; ++X)\n\t\t\t{\n\t\t\t\tif ((Edge0 >= 0.0f || (isTopLeft0 && Edge0 == 0.0f)) &&\n\t\t\t\t\t(Edge1 >= 0.0f || (isTopLeft1 && Edge1 == 0.0f)) &&\n\t\t\t\t\t(Edge2 >= 0.0f || (isTopLeft2 && Edge2 == 0.0f)))\n\t\t\t\t{\n\t\t\t\t\tu32 PixelID = (Y * GlobalState.FrameBufferWidth) + X;\n\n\t\t\t\t\tf32 T0 = -Edge1 / BaryCentricDiv;\n\t\t\t\t\tf32 T1 = -Edge2 / BaryCentricDiv;\n\t\t\t\t\tf32 T2 = -Edge0 / BaryCentricDiv;\n\n\t\t\t\t\tf32 Depth = T0 * (Vertex0.Pos.z) + T1 * (Vertex1.Pos.z) + T2 * (Vertex2.Pos.z);\n\t\n\t\t\t\t\tif (Depth >= 0.0f && Depth <= 1.0f && Depth < GlobalState.DepthBuffer[PixelID])\n\t\t\t\t\t{\n\t\t\t\t\t\tf32 OneOverW = T0 * Vertex0.Pos.w + T1 * Vertex1.Pos.w + T2 * Vertex2.Pos.w;\n\n\t\t\t\t\t\tv2 UV = T0 * (Vertex0.UV) + T1 * (Vertex1.UV) + T2 * (Vertex2.UV);\n\t\t\t\t\t\tUV /= OneOverW;\n\n\t\t\t\t\t\tu32 TextureColor = 0;\n\n\t\t\t\t\t\tswitch (Sampler.Type) \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase(SamplerType_Nearest):\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ti32 TexelX = (i32)floorf(UV.x * (Texture.Width - 1));\n\t\t\t\t\t\t\t\ti32 TexelY = (i32)floorf(UV.y * (Texture.Height - 1));\n\n\t\t\t\t\t\t\t\tif (TexelX >= 0 && TexelX < Texture.Width\n\t\t\t\t\t\t\t\t\t&& TexelY >= 0 && TexelY < Texture.Height)\n\t\t\t\t\t\t\t\t{\t\n\t\t\t\t\t\t\t\t\tTextureColor = Texture.Texels[TexelY * Texture.Width + TexelX];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tTextureColor = 0xffff00ff;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} break;\n\t\t\t\t\t\t\tcase(SamplerType_Bilinear):\n\t\t\t\t\t\t\t{\n\n\t\t\t\t\t\t\t\tv2 TexelV2 = UV * V2(Texture.Width, Texture.Height) - V2(0.5f, 0.5f);\n\t\t\t\t\t\t\t\tv2i TexelPos[4] = {};\n\t\t\t\t\t\t\t\tTexelPos[0] = V2I(floorf(TexelV2.x), floorf(TexelV2.y));\n\t\t\t\t\t\t\t\tTexelPos[1] = TexelPos[0] + V2I(1, 0);\n\t\t\t\t\t\t\t\tTexelPos[2] = TexelPos[0] + V2I(0, 1);\n\t\t\t\t\t\t\t\tTexelPos[3] = TexelPos[0] + V2I(1, 1);\n\n\t\t\t\t\t\t\t\tv3 TexelColors[4] = {};\n\n\t\t\t\t\t\t\t\tfor (u32 TexelID = { 0 }; TexelID < ArrayCount(TexelPos); TexelID++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tv2i CurrTexelPos = TexelPos[TexelID];\n\t\t\t\t\t\t\t\t\tif (CurrTexelPos.x >= 0 && CurrTexelPos.x < Texture.Width\n\t\t\t\t\t\t\t\t\t\t&& CurrTexelPos.y >= 0 && CurrTexelPos.y < Texture.Height)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tTexelColors[TexelID] = ColorU32ToRGB(Texture.Texels[CurrTexelPos.y * Texture.Width + CurrTexelPos.x]);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tTexelColors[TexelID] = ColorU32ToRGB(Sampler.BoarderColor);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tf32 S = TexelV2.x - floorf(TexelV2.x);\n\t\t\t\t\t\t\t\tf32 K = TexelV2.y - floorf(TexelV2.y);\n\n\t\t\t\t\t\t\t\tv3 Interpolated0 = Lerp(TexelColors[0], TexelColors[1], S);\n\t\t\t\t\t\t\t\tv3 Interpolated1 = Lerp(TexelColors[2], TexelColors[3], S);\n\t\t\t\t\t\t\t\tv3 FinalColor = Lerp(Interpolated0, Interpolated1, K);\n\n\t\t\t\t\t\t\t\tTextureColor = RGBToU32(FinalColor);\n\t\t\t\t\t\t\t} break;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\tInvalidCodePath; \n\t\t\t\t\t\t\t} break;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tGlobalState.FrameBufferPixels[PixelID] = TextureColor;\n\t\t\t\t\t\tGlobalState.DepthBuffer[PixelID] = Depth;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tEdge0 += Edge0DiffX;\n\t\t\t\tEdge1 += Edge1DiffX;\n\t\t\t\tEdge2 += Edge2DiffX;\n\t\t\t}\n\t\t\tEdge0RowY += Edge0DiffY;\n\t\t\tEdge1RowY += Edge1DiffY;\n\t\t\tEdge2RowY += Edge2DiffY;\n\t\t}\n\t#else\n\t...\n\t#endif ","x":-762,"y":-1982,"width":1524,"height":3964,"color":"1"}
	],
	"edges":[]
}