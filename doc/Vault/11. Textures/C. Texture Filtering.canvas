{
	"nodes":[
		{"id":"d6f35ce1f7d48fe0","type":"text","text":"\tswitch (Sampler.Type) \n\t{","x":1372,"y":-105,"width":269,"height":88,"color":"3"},
		{"id":"f82080ba528ea253","type":"text","text":"Створюємо функцію що перетворює кольори з вектора у 32бітне число","x":641,"y":-457,"width":337,"height":58,"color":"4"},
		{"id":"9f938ab838cd5a33","type":"text","text":"Створюємо функцію що перетворює кольори з 32бітного числа у вектор","x":641,"y":-540,"width":337,"height":58,"color":"4"},
		{"id":"72f796ac9b6f181f","type":"text","text":"У win32_GraphicsPractise.cpp","x":381,"y":-313,"width":260,"height":60,"color":"1"},
		{"id":"1bf6b54b4becaa15","type":"text","text":"\tu32 RGBToU32(v3 Color) \n\t{\n\t\tu32 Result = {};\n\t\tResult = ((0xFF) << 24) | (((u32)(Color.r * 255)) << 16) | (((u32)(Color.g * 255)) << 8) | ((u32)(Color.b * 255));\n\t\treturn Result;\n\t}","x":1124,"y":-532,"width":1097,"height":208,"color":"3"},
		{"id":"6c7da784c6cd0778","type":"text","text":"\tv3 ColorU32ToRGB(u32 Color) \n\t{\n\t\tv3 Result = {};\n\t\tResult.r = (Color >> 16) & 0xFF;\n\t\tResult.g = (Color >> 8) & 0xFF;\n\t\tResult.b = (Color) & 0xFF;\n\t\tResult /= 255.0f;\n\t\treturn Result;\n\t}","x":1124,"y":-832,"width":425,"height":292,"color":"3"},
		{"id":"fe6ed3540738a85d","type":"text","text":"\tvoid DrawTriangle(v3 ModelVertex0, v3 ModelVertex1, v3 ModelVertex2\n\t\t, v2 ModelUV0, v2 ModelUV1, v2 ModelUV2\n\t\t, m4 Transform, texture Texture, sampler Sampler)\n\t{","x":903,"y":-253,"width":646,"height":148,"color":"3"},
		{"id":"5d0706eaa1d8368a","type":"text","text":"У функції DrawTriangle додаємо новий аргумент - семплер","x":560,"y":-208,"width":295,"height":58,"color":"4"},
		{"id":"9494e327e60a25be","type":"text","text":"Коли починаємо шукати колір методом найближчого сусіда пишемо перемикач по типу семплера","x":664,"y":-89,"width":461,"height":58,"color":"4"},
		{"id":"9bea169c461c5342","type":"text","text":"Пишемо випадок для методу фільтрації (білінійної інтерполяції)","x":1372,"y":275,"width":332,"height":58,"color":"4"},
		{"id":"47e0b0b0d367eca9","type":"text","text":"Закидуємо весь код методу найближчого сусіда у випадок відповідного типу","x":1372,"y":10,"width":370,"height":58,"color":"4"},
		{"id":"2f40c7355f40d2bb","type":"text","text":"У кінці функції строки\n- GlobalState.FrameBufferPixels[PixelID] = TextureColor;\n- GlobalState.DepthBuffer[PixelID] = Depth;\n\n\\- не потрібно видаляти чи переміщувати","x":1317,"y":87,"width":480,"height":163,"color":"1"},
		{"id":"22aee514014ecf92","type":"text","text":"\tcase(SamplerType_Nearest):\n\t{\n\t\ti32 TexelX = (i32)floorf(UV.x * (Texture.Width - 1));\n\t\ti32 TexelY = (i32)floorf(UV.y * (Texture.Height - 1));\n\n\t\tif (TexelX >= 0 && TexelX < Texture.Width\n\t\t\t&& TexelY >= 0 && TexelY < Texture.Height)\n\t\t\t{\t\n\t\t\t\tTextureColor = Texture.Texels[TexelY * Texture.Width + TexelX];\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\t\tTextureColor = 0xffff00ff;\n\t\t\t}\n\t} break;","x":1918,"y":-179,"width":811,"height":436,"color":"3"},
		{"id":"a339caa14583598f","type":"text","text":"\tcase(SamplerType_Bilinear):\n\t{\n","x":1918,"y":260,"width":318,"height":88,"color":"3"},
		{"id":"36aa51c3a6ab3227","type":"text","text":"\tv2 TexelV2 = UV * V2(Texture.Width, Texture.Height) - V2(0.5f, 0.5f);\n","x":1919,"y":348,"width":662,"height":58,"color":"3"},
		{"id":"2eb711b0bcabafd1","type":"text","text":"\tv2i TexelPos[4] = {};\n\tTexelPos[0] = V2I(floorf(TexelV2.x), floorf(TexelV2.y));\n\tTexelPos[1] = TexelPos[0] + V2I(1, 0);\n\tTexelPos[2] = TexelPos[0] + V2I(0, 1);\n\tTexelPos[3] = TexelPos[0] + V2I(1, 1);\n","x":1919,"y":425,"width":556,"height":178,"color":"3"},
		{"id":"332f50acde79953a","type":"text","text":"\tv3 TexelColors[4] = {};\n\tfor (u32 TexelID = { 0 }; TexelID < ArrayCount(TexelPos); TexelID++)\n\t{\n\t\tv2i CurrTexelPos = TexelPos[TexelID];\n\t\tif (CurrTexelPos.x >= 0 && CurrTexelPos.x < Texture.Width\n\t\t\t&& CurrTexelPos.y >= 0 && CurrTexelPos.y < Texture.Height)\n\t\t{\n\t\t\tTexelColors[TexelID] = ColorU32ToRGB(Texture.Texels[CurrTexelPos.y * Texture.Width + CurrTexelPos.x]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tTexelColors[TexelID] = ColorU32ToRGB(Sampler.BoarderColor);\n\t\t}\n\t}","x":1919,"y":611,"width":1065,"height":412,"color":"3"},
		{"id":"a1f4513dcc230e33","type":"text","text":"\tf32 S = TexelV2.x - floorf(TexelV2.x);\n\tf32 K = TexelV2.y - floorf(TexelV2.y);\n","x":1919,"y":1023,"width":408,"height":88,"color":"3"},
		{"id":"30804fdeb4ddc2b4","type":"text","text":"\t\tv3 Interpolated0 = Lerp(TexelColors[0], TexelColors[1], S);\n\t\tv3 Interpolated1 = Lerp(TexelColors[2], TexelColors[3], S);\n\t\tv3 FinalColor = Lerp(Interpolated0, Interpolated1, K);\n\n\t\tTextureColor = RGBToU32(FinalColor);\n\t} break;","x":1919,"y":1111,"width":646,"height":208,"color":"3"},
		{"id":"620a90d3695f113b","type":"text","text":"\tdefault:\n\t{ \n\t\tInvalidCodePath; \n\t} break;","x":1919,"y":1326,"width":293,"height":148,"color":"3"},
		{"id":"b45d4810b47c405c","type":"text","text":"Вираховуємо інтерполяційні змінні по X- і Y-координатах текстури","x":1460,"y":1038,"width":323,"height":58,"color":"4"},
		{"id":"74098b5b843bacce","type":"text","text":"Інтерполюєйомо колір в точках і присвоюємо його остаточне значення до текстурки ","x":1460,"y":1186,"width":405,"height":58,"color":"4"},
		{"id":"938bf984a386c616","type":"text","text":"Присвоюємо кожному текселю його колір з текстури (якщо текселя не існує, точка знаходиться на краю, то присвоюємо йому значення кольору з рамки)","x":1460,"y":611,"width":458,"height":88,"color":"4"},
		{"id":"bafb8d36a581a8bb","type":"text","text":"Рахуємо положення точки екрану на текстурі","x":1564,"y":348,"width":250,"height":60,"color":"4"},
		{"id":"068993c586f0e223","type":"text","text":"Рахуємо положення текселів навколо точки","x":1564,"y":484,"width":250,"height":60,"color":"4"},
		{"id":"d0dc80cee97745e5","type":"text","text":"Створюємо випадок за замовчуванням що вказує на те що ми ініціалізували пустий семплер","x":1372,"y":1371,"width":429,"height":58,"color":"4"},
		{"id":"ac0b1d3fb1f29af0","type":"text","text":"\t}","x":1372,"y":1444,"width":250,"height":60,"color":"3"},
		{"id":"f197793bacc135af","type":"text","text":"\ttexture CheckerBoardTexture = {};\n\tsampler Sampler = {};\n\t{\n\t\tSampler.Type = SamplerType_Bilinear;\n\t\tSampler.BoarderColor = 0xFFFFFFFF;","x":769,"y":178,"width":457,"height":177,"color":"3"},
		{"id":"a2b91068996a4753","type":"text","text":"Коли створюємо текстуру одразу створюємо об'єкт семплеру ініціалізуючи білий колір рамки і метод Фільтрації","x":743,"y":87,"width":509,"height":58,"color":"4"},
		{"id":"e24d5abbe4ffae69","type":"text","text":"У main функції","x":560,"y":-2,"width":250,"height":60,"color":"6"},
		{"id":"0ce5336b4fceb727","type":"text","text":"У головному циклі під час малювання трикутників додаємо в аргументи семплер","x":743,"y":380,"width":378,"height":58,"color":"4"},
		{"id":"c8e6dc6a9b53a022","type":"text","text":"\tDrawTriangle(ModelVertices[Index0], ModelVertices[Index1], ModelVertices[Index2]\n\t\t, ModelUVs[Index0], ModelUVs[Index1], ModelUVs[Index2]\n\t\t, Transform, CheckerBoardTexture, Sampler);","x":368,"y":460,"width":753,"height":118,"color":"3"},
		{"id":"cf9caa4b07d7bf44","type":"text","text":"У win32_GraphicsPractise.h","x":378,"y":-582,"width":250,"height":60,"color":"1"},
		{"id":"5a64b0ef73403d65","type":"text","text":"Створюємо псевдонім типу нашого семплера (коли тип дорівнюється до 0 то і семплер буде ніяким для подальшої легкості виявлення багів)","x":378,"y":-715,"width":585,"height":58,"color":"4"},
		{"id":"a62754380c5d3b91","type":"text","text":"Створюємо структуру семплера в якій будемо зберігати його тип і колір рамки якщо при семплінгу він виявиться потрібний","x":378,"y":-657,"width":527,"height":58,"color":"4"},
		{"id":"1aacb0c135a5b8f8","type":"text","text":"\tenum sampler_type \n\t{\n\t    SamplerType_None,\n\t\n\t    SamplerType_Nearest,\n\t    SamplerType_Bilinear,\n\t};","x":378,"y":-982,"width":302,"height":238,"color":"3"},
		{"id":"f2ec4871da271282","type":"text","text":"\tstruct sampler \n\t{\n\t    sampler_type Type;\n\t    u32 BoarderColor;\n\t};","x":837,"y":-922,"width":277,"height":178,"color":"3"},
		{"id":"7d1844c5c1683c7e","type":"text","text":"У graphicsMath.h","x":0,"y":-582,"width":250,"height":60,"color":"1"},
		{"id":"ae3b7648efd3da70","type":"text","text":"Додаємо унію двовимірного вектору цілих чисел","x":-62,"y":-657,"width":312,"height":58,"color":"4"},
		{"id":"38c4f450100bf25c","type":"text","text":"\tunion v2i\n\t{\n\t\tstruct\n\t\t{\n\t\t\ti32 x, y;\n\t\t};\n\n\t\ti32 e[2];\n\t};","x":-62,"y":-978,"width":302,"height":292,"color":"3"},
		{"id":"0e4eb74327d33798","type":"text","text":"У graphicsMath.cpp","x":0,"y":-482,"width":250,"height":60,"color":"1"},
		{"id":"92b5005336fae0d4","type":"text","text":"Створюємо функцію для ініціалізації двовимірного вектору із цілих чисел","x":-85,"y":-414,"width":335,"height":58,"color":"4"},
		{"id":"7d2655914a5056de","type":"text","text":"Пишемо оператори:\n- додавання двовимірних цілих векторів\n- поділити й присвоїти для двовимірного вектора і числа\n- помножити і присвоїти для трьовимірного вектору і числа","x":-283,"y":-354,"width":533,"height":146,"color":"4"},
		{"id":"5a75d54993b9e7f6","type":"text","text":"Створюємо функцію інтерполяції двох атрибутів по заданому коефіціенту","x":-99,"y":-208,"width":349,"height":58,"color":"4"},
		{"id":"0f1e4ba278a922ff","type":"text","text":"\tv3 Lerp(v3 A, v3 B, f32 T) \n\t{\n\t\tv3 Result = (1.0f - T) * A + T * B;\n\t\treturn Result;\n\t}","x":-99,"y":-132,"width":449,"height":178,"color":"3"},
		{"id":"ac3032e59db898ef","type":"text","text":"\tv3 operator*=(v3& A, f32 B)\n\t{\n\t\tA.x = A.x * B;\n\t\tA.y = A.y * B;\n\t\tA.z = A.z * B;\n\t\treturn A;\n\t}","x":-480,"y":-192,"width":318,"height":238,"color":"3"},
		{"id":"8c93fb96ee31fc1b","type":"text","text":"\tv2i V2I(f32 X, f32 Y)\n\t{\n\t\tv2i Result = {};\n\t\tResult.x = (i32)X;\n\t\tResult.y = (i32)Y;\n\t\treturn Result;\n\t}","x":-472,"y":-686,"width":310,"height":238,"color":"3"},
		{"id":"1aa610c07cb7723f","type":"text","text":"\tv2 operator/=(v2& A, f32 B)\n\t{\n\t\tA.x = A.x / B;\n\t\tA.y = A.y / B;\n\t\treturn A;\n\t}","x":-820,"y":-192,"width":318,"height":208,"color":"3"},
		{"id":"dd829d79b9756e12","type":"text","text":"\tv2i operator+(v2i A, v2i B)\n\t{\n\t\tv2i Result = {};\n\t\tResult.x = A.x + B.x;\n\t\tResult.y = A.y + B.y;\n\t\treturn Result;\n\t}","x":-862,"y":-547,"width":360,"height":238,"color":"3"},
		{"id":"a1b35d4a32bdcb60","type":"text","text":"Нехай ми й маємо правильну інтерполяцію текстури на поверхню, проте зображення все ще не виглядає досить добре, це пов'язано з тим що ми маємо досить низьку кілцькість у самомму екрані і дійсно якщо виставити якість вікна на таку саму що й параметри монітору то зображення стане чіткішим, проте при віддаленні від куба воно все ще буде ставати менш розбірливим.\n\nЩоб уникнути цього ефекту ми повинні використовувати метод фільтрації або білінійної інтерполяції. Він полягає в тому щоб відмальовувати інтерпольований колір між текселями текстури якщо піксель екрану не потрапляє рівно у центр текселю. В такомму разі ми позбавимося ефекту коли наша текстура має більший розмір ніж розмір ділянки вікна на якій вона малюється через що рух навколо об'єкту викликає ефект наче текстурка рухається замість того щоб просто повертатися, це пов'язано з тим що ми використовуємотільки пікселі що були наявні у текстурі і при русі замість плавної змінни кольору воно ступінчато переходять на інший колір, що виглядає наче цей піксель взявся нізвідки. Якщо ж ми додамо проміжні пікселі то це збільшить \"стабільність\" картинки і ми будемо бачити текстурку як накладений на сторону куба малюнок незалежно від руху навколо нього.","x":-640,"y":217,"width":801,"height":404,"color":"1"},
		{"id":"875c6acb4c504b2f","type":"text","text":"ФІльтрація текстури (білінійна інтерполяція):\n- це інший метод семплінгу текстури що полягає в виборі кольору завдяки інтерполяції кольору між текселями\n- для нашої реалізації знадобиться 3 інтерполяції для знаходженння одного пікселя екрану:\n\t- між кольорами нижнього лівого і нижнього правого тексклів\n\t- між кольорами верхнього лівого і верхнього правого тексклів\n\t- між отриманими кольорами верха і низа\n- ми будемо рахувати кожен піксель так наче він знаходиться у квадраті краї якого є центрами текселів\n- спочатку помножимо UV-координати поточної точки на ширину і висоту текстурки і віднімемо 0.5\n- тим самим ми зможемо знайти координати точок кубів просто використавши функцію floor() і додавши 1 до відповідних координат:\n\t- Лівий нижній тексель - (floor(x), floor(y))\n\t- Лівий верхній тексель - (floor(x), floor(y) + 1)\n\t- Правий нижній тексель - (floor(x) + 1, floor(y))\n\t- Правий верхній тексель - (floor(x) + 1, floor(y) + 1)\n- Після ми напишемо функцію інтерполяції і використаємо її 3 рази щоб знайти потрібний колір\n\t- bottomCol = lerp(bottomLeftCol, bottomRightCol, s)\n\t- topCol = lerp(topLeftCol, topRightCol, s)\n\t- resultCol = lerp(bottomCol, topCol, k)\n\t\t- , де s = x - floor(x) ,k = y - floor(y) - змінні інтерполяції для відповідних осей координат X і Y","x":-640,"y":658,"width":1083,"height":540,"color":"#c800ff"},
		{"id":"e4d3f1a0ed4ddddd","type":"text","text":"Але у такого методу можна побачити проблему: \n- якщо піксель екрану буде на краю текстури, то буде лише один-два текселі замість потрібних чотирьох\n\nЄ багато різних способів вирішити цю  проблему але ми оберемо нафпростіший:\n- для цих неіснуючих текселів будемо використовувати колір рамки текстури що буде зберігатися у структурі самої текстури","x":-640,"y":1217,"width":1025,"height":183,"color":"#ff00a2"}
	],
	"edges":[
		{"id":"bde24b8aa448c6a2","fromNode":"9f938ab838cd5a33","fromSide":"right","toNode":"6c7da784c6cd0778","toSide":"left"},
		{"id":"36e500c81ccad3f0","fromNode":"f82080ba528ea253","fromSide":"right","toNode":"1bf6b54b4becaa15","toSide":"left"},
		{"id":"93e6c148f37a3b8b","fromNode":"72f796ac9b6f181f","fromSide":"top","toNode":"f82080ba528ea253","toSide":"left"},
		{"id":"c1a68b90054ed3e6","fromNode":"72f796ac9b6f181f","fromSide":"top","toNode":"9f938ab838cd5a33","toSide":"left"},
		{"id":"1fc0bd86e9f89568","fromNode":"5d0706eaa1d8368a","fromSide":"right","toNode":"fe6ed3540738a85d","toSide":"left"},
		{"id":"74c600178a5a5012","fromNode":"9494e327e60a25be","fromSide":"right","toNode":"d6f35ce1f7d48fe0","toSide":"left"},
		{"id":"6ebea7081e7e581a","fromNode":"47e0b0b0d367eca9","fromSide":"right","toNode":"22aee514014ecf92","toSide":"left"},
		{"id":"cad020c1b187d0a4","fromNode":"9bea169c461c5342","fromSide":"right","toNode":"a339caa14583598f","toSide":"left"},
		{"id":"c44812b20b3504a6","fromNode":"bafb8d36a581a8bb","fromSide":"right","toNode":"36aa51c3a6ab3227","toSide":"left"},
		{"id":"a322bb78a20e4633","fromNode":"068993c586f0e223","fromSide":"right","toNode":"2eb711b0bcabafd1","toSide":"left"},
		{"id":"17ba77a6b49cf267","fromNode":"938bf984a386c616","fromSide":"bottom","toNode":"332f50acde79953a","toSide":"left"},
		{"id":"af7dde11a90e78f6","fromNode":"b45d4810b47c405c","fromSide":"right","toNode":"a1f4513dcc230e33","toSide":"left"},
		{"id":"b178da65ad4d629e","fromNode":"74098b5b843bacce","fromSide":"right","toNode":"30804fdeb4ddc2b4","toSide":"left"},
		{"id":"f87b064f9ee67306","fromNode":"47e0b0b0d367eca9","fromSide":"bottom","toNode":"2f40c7355f40d2bb","toSide":"top"},
		{"id":"6c9c67b6f02da59b","fromNode":"47e0b0b0d367eca9","fromSide":"left","toNode":"9bea169c461c5342","toSide":"left"},
		{"id":"0914147c11de8357","fromNode":"d6f35ce1f7d48fe0","fromSide":"left","toNode":"47e0b0b0d367eca9","toSide":"left"},
		{"id":"3ff003f907865019","fromNode":"5d0706eaa1d8368a","fromSide":"left","toNode":"9494e327e60a25be","toSide":"left"},
		{"id":"c16f333fb318eee8","fromNode":"72f796ac9b6f181f","fromSide":"bottom","toNode":"5d0706eaa1d8368a","toSide":"left"},
		{"id":"c6aa298c7c0f299d","fromNode":"9bea169c461c5342","fromSide":"bottom","toNode":"bafb8d36a581a8bb","toSide":"left"},
		{"id":"9e97e53247891494","fromNode":"bafb8d36a581a8bb","fromSide":"left","toNode":"068993c586f0e223","toSide":"left"},
		{"id":"2a63a81636e40d9d","fromNode":"938bf984a386c616","fromSide":"left","toNode":"b45d4810b47c405c","toSide":"left"},
		{"id":"1bce02b28b95ff80","fromNode":"b45d4810b47c405c","fromSide":"left","toNode":"74098b5b843bacce","toSide":"left"},
		{"id":"3ac4f98ed7a85558","fromNode":"9bea169c461c5342","fromSide":"left","toNode":"d0dc80cee97745e5","toSide":"left"},
		{"id":"b8bbf2e41251d0fe","fromNode":"d0dc80cee97745e5","fromSide":"right","toNode":"620a90d3695f113b","toSide":"left"},
		{"id":"b077a9f65d76676f","fromNode":"068993c586f0e223","fromSide":"bottom","toNode":"938bf984a386c616","toSide":"top"},
		{"id":"05b0eb2ebd9cab7c","fromNode":"d6f35ce1f7d48fe0","fromSide":"left","toNode":"ac0b1d3fb1f29af0","toSide":"left"},
		{"id":"609bec6681a87f83","fromNode":"a2b91068996a4753","fromSide":"bottom","toNode":"f197793bacc135af","toSide":"top"},
		{"id":"25e2eaffb37b4e13","fromNode":"e24d5abbe4ffae69","fromSide":"bottom","toNode":"a2b91068996a4753","toSide":"left"},
		{"id":"ed01a8c50072a2a9","fromNode":"0ce5336b4fceb727","fromSide":"right","toNode":"c8e6dc6a9b53a022","toSide":"right"},
		{"id":"06dc1bf710b8cb7f","fromNode":"a2b91068996a4753","fromSide":"left","toNode":"0ce5336b4fceb727","toSide":"left"},
		{"id":"3ef0f3e622aaf2ea","fromNode":"72f796ac9b6f181f","fromSide":"bottom","toNode":"e24d5abbe4ffae69","toSide":"left"},
		{"id":"e756e80a2d75d9aa","fromNode":"a62754380c5d3b91","fromSide":"right","toNode":"f2ec4871da271282","toSide":"bottom"},
		{"id":"e876ca13246ebf6d","fromNode":"5a64b0ef73403d65","fromSide":"left","toNode":"1aacb0c135a5b8f8","toSide":"left"},
		{"id":"a9f80cecf5fbcdad","fromNode":"cf9caa4b07d7bf44","fromSide":"left","toNode":"5a64b0ef73403d65","toSide":"left"},
		{"id":"040defa373662120","fromNode":"cf9caa4b07d7bf44","fromSide":"left","toNode":"a62754380c5d3b91","toSide":"left"},
		{"id":"6885f32b9384a36c","fromNode":"7d1844c5c1683c7e","fromSide":"right","toNode":"ae3b7648efd3da70","toSide":"right"},
		{"id":"ede6e9919a1d02b3","fromNode":"ae3b7648efd3da70","fromSide":"left","toNode":"38c4f450100bf25c","toSide":"left"},
		{"id":"0990ac941538aafc","fromNode":"5a75d54993b9e7f6","fromSide":"left","toNode":"0f1e4ba278a922ff","toSide":"left"},
		{"id":"9d4b69bd0c800300","fromNode":"7d2655914a5056de","fromSide":"left","toNode":"ac3032e59db898ef","toSide":"top"},
		{"id":"0fd0cb5b38eb75ca","fromNode":"92b5005336fae0d4","fromSide":"left","toNode":"8c93fb96ee31fc1b","toSide":"bottom"},
		{"id":"545404ca6de46cad","fromNode":"7d2655914a5056de","fromSide":"left","toNode":"dd829d79b9756e12","toSide":"right"},
		{"id":"e35339356d30921b","fromNode":"7d2655914a5056de","fromSide":"left","toNode":"1aa610c07cb7723f","toSide":"top"}
	]
}