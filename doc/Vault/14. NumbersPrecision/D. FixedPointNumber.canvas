{
	"nodes":[
		{"id":"034d5546f069a707","type":"file","file":"!Personal/Now/CG/Labs/CPlusPlus3DRender/14. NumbersPrecision/PNG/Pasted image 20241007235516.png","x":-20,"y":-231,"width":400,"height":182,"color":"#ff0066"},
		{"id":"09dd193d2c23e58b","type":"text","text":"Ми можемо помітити що тепер відмалювання стало  менш плавним\n\nЦе пов'язано з тим що до цього ми враховували субпіксельне положення точок, а зараз лише положення в пікселі","x":-440,"y":-231,"width":364,"height":182,"color":"#ff0066"},
		{"id":"c7b6cb23e2e2b198","type":"text","text":"Спробуємо додати цілочислене субпіксельне положення пікселів, для цього коли ми перетворюємо число з NDC простору до простору екрану ми просто можемо його помножити додатково на 2^N, де N - кількість бітів що ми хочемо використати для субпіксельного положення, і таким чином отримаємо потрібну кількість субпікселів у числі\n\nМи хочемо мати 256 субпіксельних значень, тому використаємо 8 біт із 32 бітів нашого цілого числа, таким чином для кодування положення залишиться 24 біти\n\nПотім ми просто можемо використовувати ці числа у нашому рівнянні ребер","x":-440,"y":-20,"width":638,"height":300,"color":"#ff0095"},
		{"id":"c7d2ee82ace39fcf","type":"text","text":"Таким чином м отримаємо число останні 8 біт якого вказують не на цілочислену частину а на дробову, такі числа називають дробами з фіксованою точкою, і вони як і цілі числа можуть переповнюватися і недоповнюватися","x":260,"y":-25,"width":655,"height":88,"color":"#ff0095"},
		{"id":"a970d0048ab4792c","type":"text","text":"Але також такі числа при множенні збільшують свою дробову частину, яка може стати більшою ніж N і тоді те що записано в нижчіх бітах просто буде відкидатися","x":260,"y":86,"width":471,"height":88,"color":"#ff0095"},
		{"id":"413555151ba55925","type":"text","text":"Маємо проблему, так як тепер наше ціле число має лише 24 біти цілого значення, як ми пам'ятаємо цього вистачить лише для меж екрану менших за 1023 пікселі","x":260,"y":202,"width":476,"height":88,"color":"#ff00c8"},
		{"id":"a65fc7c9d7676cfa","type":"file","file":"!Personal/Now/CG/Labs/CPlusPlus3DRender/14. NumbersPrecision/PNG/Pasted image 20241008150013.png","x":900,"y":-27,"width":649,"height":315,"color":"#ff0095"},
		{"id":"978ade72eab49e25","type":"text","text":"Тобто щоб уникнути переповнення ми можемо використовувати лише 11 бітів числа, чого не достатньо щоб уникнути проблеми точності растеризатора","x":258,"y":320,"width":480,"height":88,"color":"#ff00c8"},
		{"id":"ecadaefc4afe4eaa","type":"text","text":"Але і для 8 субпіксельних біт ми повинні враховувати точність растеризації, тобто матимемо 11+8 = 19 біт під пікселі, що потребують 40 біт для точної растеризації\n\nПроте наш алгоритм використовує дельти між піскелями, спробуємо використати це щоб умістити інофрмацію з 40 бітів у 32","x":260,"y":431,"width":562,"height":168,"color":"#ff00c8"},
		{"id":"5f1de5e9d0d82987","type":"text","text":"Тепер розрахуємо формулу для дельт рівнняня ребер\n\nЗапишемо рівняння ребер як функцію F(x, y)\nТоді раніше нам потрібно було виразувати різницю між F(x, y) і F(x + 1, y) для осі Х і різницю між F(x, y) і F(x, y + 1) для осі Y\nАле зараз у нашій 32 бітній змінні останні 8 біт відповідають не за ціле число а за його дробову частину, тому ми збільшуємо не на 1 а на 256\n\nОтже diffX:\n- = F(x + 256, y) - F(x, y)\nОтже diffY:\n- = F(x, y + 256) - F(x, y)\n\nF(x, y) = |(P - A)| x |(B - A)| = (P - A)x\\*(B - A)y - (P - A)y\\*(B - A)x\n- = Px\\*(B - A)y - Ax\\*(B - A)y - Py\\*(B - A)x + Ay\\*(B - A)x\n- = Px\\*(B - A)y - Py\\*(B - A)x -Ax\\*By + Ax\\*Ay + Ay\\*Bx - Ay\\*Ax\n- = Px\\*(B - A)y - Py\\*(B - A)x -Ax\\*By + Ay\\*Bx\n- Будемо використовувати цю формулу для підстановки\n\ndiffX =\n- (Px + 256 )\\*(B - A)y - Py\\*(B - A)x -Ax\\*By + Ay\\*Bx - (Px\\*(B - A)y - Py\\*(B - A)x -Ax\\*By + Ay\\*Bx)\n- = (Px + 256 )\\*(B - A)y - Px\\*(B - A)y\n- = (Px + 256 - Px)\\*(B - A)y \n- = 256\\*(B - A)y\n\ndiffY =\n- Px\\*(B - A)y - (Py+ 256)\\*(B - A)x -Ax\\*By + Ay\\*Bx - (Px\\*(B - A)y - Py\\*(B - A)x -Ax\\*By + Ay\\*Bx)\n- =  - (Py+ 256)\\*(B - A)x + Py\\*(B - A)x\n- = (-Py - 256 + Px)\\*(B - A)x\n- = -256\\*(B - A)x\n\nБачимо що дельти кратні 256, тобто останні 8 біт в нашому алгоритмі ніколи не будуть змінюватися","x":900,"y":320,"width":785,"height":893,"color":"#fb00ff"},
		{"id":"e4830a817f1a38bc","type":"text","text":"Отже перепишемо алгоритм так щоб спочатку ми записували результат у 64 бітну змінну, де і було б записано субпіксельне положення, а потім просто ділимо на 256 і округлюємо записуючи результат у 32 бітну зміну","x":260,"y":1125,"width":604,"height":88,"color":"#fb00ff"}
	],
	"edges":[
		{"id":"f781de3e80dc94db","fromNode":"09dd193d2c23e58b","fromSide":"right","toNode":"034d5546f069a707","toSide":"left"},
		{"id":"6ccf87faba3e536f","fromNode":"c7b6cb23e2e2b198","fromSide":"right","toNode":"c7d2ee82ace39fcf","toSide":"left"},
		{"id":"136809734386a93a","fromNode":"a970d0048ab4792c","fromSide":"right","toNode":"a65fc7c9d7676cfa","toSide":"left"},
		{"id":"f9d1464b8e434db9","fromNode":"c7b6cb23e2e2b198","fromSide":"right","toNode":"a970d0048ab4792c","toSide":"left"},
		{"id":"6373567717a14f6f","fromNode":"c7b6cb23e2e2b198","fromSide":"right","toNode":"413555151ba55925","toSide":"left"},
		{"id":"3507c4321862bb27","fromNode":"413555151ba55925","fromSide":"bottom","toNode":"978ade72eab49e25","toSide":"top"},
		{"id":"95b67f483db914ed","fromNode":"978ade72eab49e25","fromSide":"left","toNode":"ecadaefc4afe4eaa","toSide":"left"},
		{"id":"04b2cbf1eff8f45f","fromNode":"ecadaefc4afe4eaa","fromSide":"right","toNode":"5f1de5e9d0d82987","toSide":"left"},
		{"id":"acb9a976d6d9ba67","fromNode":"5f1de5e9d0d82987","fromSide":"left","toNode":"e4830a817f1a38bc","toSide":"top"}
	]
}