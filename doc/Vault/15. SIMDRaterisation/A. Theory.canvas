{
	"nodes":[
		{"id":"b9908cdcf4c35ff7","type":"text","text":"SIMD (Single Instruction/Multiple Data)\n- Зараз CPUs мають інструкції що працюють з багатьма данними\n- в архітектурі х86-64 ці системи називаються SSE та AVX:\n\t- SSE2-4.2 має інструкції що працюють з 4 числами\n\t- AVX1-2 має інструкції що працюють з 8 числами\n\t- AVX512 має інструкції що працюють з 16 числами","x":-300,"y":-220,"width":510,"height":243,"color":"#ff0066"},
		{"id":"6aeeb65d51cefee1","type":"text","text":"Довідник для цих інструкцій\n- https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html\n- або загугливши intel intrinsics guide","x":300,"y":-242,"width":379,"height":144,"color":"5"},
		{"id":"c10ab3e07c0c251c","type":"text","text":"Будемо використовувати SSE інструкції, проте ви можете сспробувати інший варіант якщо ваш процессор підтримує його","x":-300,"y":40,"width":394,"height":88,"color":"#ff0095"},
		{"id":"162b4200a6917dfe","type":"text","text":"Типи данних\n- ми можемо кодувати цілі числа і числа з плаваючою точкою:\n\t- \\_\\_m128 - набір чисел з плаваючою комою\n\t- \\_\\_m128i - набір цілочислених чисел\n\t- 128 вказує на кількість бітів, ми можемо дати наприклад 4 числа по 32 біти, або 2 числа по 64 біти","x":-300,"y":140,"width":555,"height":210,"color":"#ff0095"},
		{"id":"11a790b525096e8f","type":"text","text":"Функції\n- Мають форму:\n\t- \\_mm\\_command\\_numtype(arguments)\n- numtype\n\t- ps - 32 бітне число з плаваючою комою\n\t- epi32 - 32 бітне ціле число\n- command\n\t- set - дає значення змінній\n\t- add - додає дві змінні одного типу\n\t- mul - множеть дві змінні одного типу\n\n\t- cmpge - порівняння чи є перший аргумент більший або дорівнює другому аргументу (CoMPare Greater then/Equal to)\n\t\t- значення true на виході буде мати усі біти 1, а false - 0\n\n\t- cvtps - перетворює цілочислені типи у числа з плаваючою точкою\n\n\t- loadu - завантажити данні з вказівника без вирівнювання\n\t- load - завантажити данні з вказівника з вирівнюванням\n\t- storeu - завантажити данні у вказівник без вирівнювання\n\t- store - завантажити данні у вказівник з вирівнюванням","x":280,"y":140,"width":629,"height":538,"color":"#ff0095"},
		{"id":"a7aaf5872b726ee5","type":"text","text":"Вирівнювання\n- так як тип \\_\\_m128 має розмір у 16 байтів, то при зчитуванні данних з С++ вказівників ми повинні вирівняти їх до 16 байтів, інакше программа крашнеться:\n\t- aligned_alloc - у С\n\t- new (std::align_val_t(16)) Type - у С++\n- або ми можемо використовувати команди store і load що самі виконують вирівнювання","x":-300,"y":408,"width":522,"height":270,"color":"#ff0095"},
		{"id":"5be179d012ae898a","type":"text","text":"SIMD у растеризаці\n- Етапи растеризації:\n\t- Обчислення і тестування ребер\n\t- Обчислення і тестування глибини\n\t- Семплінг текстури\n\t- Зберігання кольору/глибини","x":940,"y":-220,"width":401,"height":213,"color":"#ff00c8"},
		{"id":"b42e1263d222d9fb","type":"text","text":"Маскування\n- Наразі ми не можемо використовувати оператор вітвлення if так як нам потрібно його використати для багатьох змінних одночасно\n- Тому спробуємо його емулювати за допомогою інших можливостей мови\n\nАлгоритм маскування\n- Спочатку ми вирахуємо вихідний результат if стейтменту\n\t- int TrueCase = sqrt(x);\n- Потім вирахуємо вихідний результат else стейтменту\n\t- int FalseCase = pow(x, 2);\n- Після вирахуємо значення умови нашого оператора\n\t- bool ConditionMask = (x > 0);\n- Тепер можемо вирахувати вихідний результат по формулі\n\t- x = (ConditionMask \\* TrueCase) + (!ConditionMask \\* FalseCase);\n\nАдаптація алгоритму до SIMD чисел\n- Єдина проблема цього алгоритма, в тому що значення true в нас буде не 0x01, а 0xFFFFFFFF, але ми можемо це легко виправити додавши додаткові кроки\n\t- ResultTrue = ConditionMask & TrueCase\n\t- ResultFalse = ConditionMask & FalseCase\n- А потім останній рядок буде\n\t- x = (ConditionMask \\* ResultTrue) + (!ConditionMask \\* ResultFalse);\n- Таким чином ми також можемо переписувати значення у буффер пікселів, просто використовуєчи замість FalseCase значення пікселів до обрахунку, а замість TrueCase значення обрахованих пікселів","x":1600,"y":-220,"width":680,"height":741,"color":"#fb00ff"},
		{"id":"bbbf6ab42ad997fe","type":"text","text":"Обчислення і тестування ребер\n- Спочатку в нашому коді ми обчислювали рівняння ребер нижнього лівого кута прямокутника описуючого полігон (MinX+0.5, MinY+0.5)\n- Так як ми маємо 4 числа у змінній, то і доведеться нам одночасно обчислювати 4 пікселі\n\t- Edge0RowY_4x = Edge0RowY + (1, 2, 3, 4) \\* Edge0DiffX\n\t- , де Edge0RowY має 4 значення (Edge0RowY)\n\t- Edge0DiffX має 4 значення (Edge0DiffX)\n- Таким чином ми можемо ініціалізувати початкові 4 пікселі\n- Далі обчислимо Edge0DiffY_x4\n\t- , так як ми хочемо просто зміщувати кожен піксель на 1 вгору то і будемо мати просто 4 значення Edge0DiffY\n- Перейдимо до Edge0DiffX_x4\n\t- , так як ми обчислюємо натепер 4 значення, то і переходити ми будемо з кроком не в один, а у чотири, тобто значення буде 4 однакові числа (4\\*Edge0DiffX)\n- Для перевірки пікселя на знаходження всередині ребра використаємо маскування","x":940,"y":20,"width":604,"height":540,"color":"#fb00ff"},
		{"id":"dd1ce39fe2c31561","type":"text","text":"Зберігання кольору/глибини\n- Також використаємо маскування для зберігання нових значень кольору до буферу","x":940,"y":580,"width":436,"height":109,"color":"#fb00ff"},
		{"id":"81ba8998d0852e44","type":"text","text":"Переповнення\n- Так як ми читаємо пам'ять по 4 пікселі за раз, то якщо наше вікно не кратно 4 пікселям у буффері, то при зчитуванні у нас виникне ситуація коли ми зчитуємо пам'ять що не належить буфферу і програма завершить свою роботу\n- Для уникнення цієї ситуації ми можемо створити додаткові 3 пікселі в кінці кожного рядка, які не матимуть корисної інформації, таким чином ми уникнемо проблеми","x":1500,"y":689,"width":543,"height":263,"color":"#fb00ff"}
	],
	"edges":[
		{"id":"a9b05d568ae5b87b","fromNode":"b9908cdcf4c35ff7","fromSide":"right","toNode":"6aeeb65d51cefee1","toSide":"left"},
		{"id":"39248ff6c96ebf9c","fromNode":"bbbf6ab42ad997fe","fromSide":"right","toNode":"b42e1263d222d9fb","toSide":"left"},
		{"id":"9377914f54b5b262","fromNode":"b42e1263d222d9fb","fromSide":"bottom","toNode":"dd1ce39fe2c31561","toSide":"right"},
		{"id":"363a79b9a29a7d75","fromNode":"dd1ce39fe2c31561","fromSide":"bottom","toNode":"81ba8998d0852e44","toSide":"left"},
		{"id":"5020860542d9f5f6","fromNode":"c10ab3e07c0c251c","fromSide":"left","toNode":"162b4200a6917dfe","toSide":"left"},
		{"id":"41866c9b395da97d","fromNode":"c10ab3e07c0c251c","fromSide":"right","toNode":"11a790b525096e8f","toSide":"top"},
		{"id":"2017c11573980909","fromNode":"162b4200a6917dfe","fromSide":"left","toNode":"a7aaf5872b726ee5","toSide":"left"}
	]
}