{
	"nodes":[
		{"id":"3614d84f8d624a2e","type":"text","text":"Якщо подивитися на полігони з якоїсь незвичайної позиції, наприклад зсередини об'єкта то ми можемо побачити дуже дивну поведінку.\n\nПрограмма малює полігони які ми не програмували.\nДля того щоб раз і назавжди прибрати цю проблему напишемо алгоритм відсікання, що буде відсікати частини полігонів які не потрапляють в простір камери","x":-340,"y":-460,"width":701,"height":167,"color":"#ff0066"},
		{"id":"51e04ffa1862db7f","type":"text","text":"Проблемні випадки нашого алгоритму:\n- Полігон перетинає камеру\n- Точка має глибину нуль (відбуватиметься поділ на нуль)\n- Полігон має дуже велику площу, через що барицентричні координати обчислюються некорректно","x":-340,"y":-280,"width":516,"height":176,"color":"#ff0066"},
		{"id":"960699b89895c096","type":"text","text":"Відсікання:\n- це алгоритм який дивиться чи є трикутник в полі зору камери:\n\t- якщо так, то він малює його\n\t- якщо ні, то не малює\n\t- якщо частина знаходиться, то другу частину відсікає і отриманний трикутник малює\n- алгоритм виконується після множення на матрицю перспективи, але перед нормалізацією діленням на w-координату, цей простір називається простором відсікання або простором кліпу","x":-340,"y":-80,"width":580,"height":296,"color":"#ff0095"},
		{"id":"1bbe76861b79b98a","type":"text","text":"Випадки відсікання:\n- Усього існує 4 випадки:\n\t- 0 вершин знаходяться за простором площини - трикутник залишається у буфері\n\t- 1 вершина знаходяться за простором площини - відсікаємо вершину, знаходимо дві точки перетину з площиною і формуємо два трикутники з двох старих і двох нових вершин\n\t- 2 вершини знаходяться за простором площини - відсікаємо дві вершини, знаходимо дві точки перетину з площиною, формуємо трикутник з однієї старої і двох нових вершин\n\t- 3 вершини знаходяться за простором площини - відсікаємо увесь трикутник","x":-340,"y":403,"width":728,"height":320,"color":"#ff00c8"},
		{"id":"29b96f38edbb3253","type":"text","text":"Піраміда огляду:\n- це множима площин які формують собою увесь простір що буде зображуватися у камеру\n- Усього таких площин 6: Верхня, Нижня, Ліва, Права, Близька, Далека\n- Відповідно наш алгоритм буде перевіряти кожного трикутника по шістьох площинах","x":-340,"y":223,"width":728,"height":176,"color":"#ff00c8"},
		{"id":"868471de6aae3b30","type":"text","text":"Алгоритм відсікання:\n- Вхідні данні - вхідний массив вершин (їх положення і uv-координати), вісь для якої ми відсікаємо трикутника (усього 4 вісь: X, Y, Z, W)\n- Вихідні данні - вихідний массив вершин\n\nАлгоритм:\n- Кожний трикутник ми ітеруємо окремо,\n- Обчислюємо чи є вершина за межами вісі функцією ClippingIsBehindPlane(Vertice, Axis)\n- Рахуємо кількість вершин за межами осі і обираємо відповідний код для різних випадків:\n\t- Всі вершини у межах вісі - записуємо вершини трикутника у вихідний массив\n\t- 1 або 2 Вершини за межами вісі - ітеруємо кожне ребро трикутника: \n\t\t- знаходимо які ребра перетинають межі вісі і яка точка ребра знаходиться всередині меж\n\t\t- рахуємо точку претину з межою віссі функцією ClippingCalculateIntersection(StartVertex, EndVertex, Axis)\n\t\t- записуємо нові і старі точки до вихідного массиву формуючи правильно відображаємі трикутники\n\t- Всі вершини за межами вісі - не додаємо нічого в вихідний массив","x":400,"y":-460,"width":760,"height":561,"color":"#ff00f7"},
		{"id":"26f34083ddf58ae3","type":"text","text":"Функція IsBehindPlane:\n- P' - це точка після нормалізації\n- P - це точка до нормаліції\n- Розглянемо випадки для осей X і Y:\n\t- P'x = Px / Pw\n\t- Ми хочемо щоб P'x було у межах від -1 до 1\n\t\t- -1 <= Px / Pw <= 1\n\t- Множимо усі частини нерівності на Pw\n\t\t- -Pw <= Px <= Pw\n\t- Аналогічно для осі Y:\n\t\t- -Pw <= Py <= Pw\n- Розглянемо випадок для осі Z:\n\t- P'z = Pz / Pw\n\t- Ми хочемо щоб P'z було у межах від 0 до 1\n\t\t- 0 <= Pz / Pw <= 1\n\t- Множимо усі частини нерівності на Pw\n\t\t- 0 <= Pz <= Pw\n- Розглянемо випадок для осі W:\n\t- P'w = Pw\n\t- Ми хочемо щоб Pw було більше 0 (менше - об'єкт ззаду камери, дорівнює до нуля - ми ділимо на 0)\n\t\t- 0 < Pw\n\t- Проте через те що наші числа зберігаються у обмеженому просторі пам'яті подібна перевірка може призводити до помилок\n\t\t- Використаємо число більше за нуль про те все ще досить мале щоб ми не відсікал об'єкти що ми повинні бачити:\n\t\t\t- 0.00001 < Pw","x":1212,"y":-460,"width":624,"height":771,"color":"#c800ff"},
		{"id":"0401ff003e1eaba4","type":"text","text":"Функція CalculateIntersection:\n- Розглянемо випадок для осей X і Y:\n\t- Будемо дивитися на кожну вісь окремо, тоді\n\t- Розглянемо площину X і W координат, тоді площина Права буде на неї проектуватися у вигляді лінії що переходить точки (0, 0) і (1, 1) у цій площині, а Ліва - (0, 0) і (-1, 1)\n\t\t- A(k) = (0, 0) + k \\* (1, 1)\n\t\t\t- , де A(k) це точка на прямій яка визначається коефіціентом k\n\t- Також ми маємо дві точки t0 - знаходиться за межами, t1 - у межах\n\t\t- Τ(s) = t0 + s \\* d\n\t\t\t- , де Τ(s) це точка між точками t1 і t0 при s належить до \\[0, 1]\n\t\t\t- d = (t1 - t0)\n\t- Нам потрібно знайти точку на перетині цих відрізків:\n\t\t- A(k) = Τ(s)\n\t\t- (0, 0) + k * (1, 1) = t0 + s \\* d\n\t\t- k = t0 + s \\* d\n\t- Розіб'ємо це рівняння для точок на два рівняння для координат:\n\t\t- k = t0x + s \\* dx\n\t\t- k = t0w + s \\* dw\n\t- Тепер ми можемо відняти друге рівняння від першого і вивести формулу для коефіціента:\n\t\t- 0 = t0x + s \\* dx - t0w - s \\* dw\n\t\t- t0w - t0x = s \\* (dx - dw)\n\t\t- s = (t0w - t0x) / (dx - dw)\n\t- Якщо ж рахуємо точку перетину з лівою площиною, то в розрахунках використовуємо точку (-1, 1) а не (1, 1), і отримаємо:\n\t\t- s = - (t0w + t0x) / (dx + dw)\n\t- Для осі Y і W справедливий такий самий вивід, тільки замість X координати буде Y:\n\t\t- Верхня площина: s = (t0w - t0y) / (dy - dw)\n\t\t- Верхня площина: s = - (t0w + t0y) / (dy + dw)\n- Розглянемо випадок для осі Z:\n\t- Так як умова для Далекої площини схожа на умови для Правої площини і Верхньої, то розрахунок буде таким самим за виключенням того що використовуємо Z координату:\n\t\t- s = (t0w - t0z) / (dz - dw)\n\t- Тепер будемо шукати коефіціент для Близької площини:\n\t\t- Запишемо рівняння для Z координати між двома точками:\n\t\t\t- T(s)z = t0z + s \\* dz\n\t\t- Пам'ятаємо що умова для цієї площини є щоб координата була більша ніж нуль, тобто точка зіткнення буде там де Z = 0:\n\t\t\t- 0 = t0z + s \\* dz\n\t\t\t- s = - (t0z) / (dz)\n- Розглянемо випадок для осі W:\n\t- Він подібний до випадку Близької площини, проте наша точка зіткнення буде де W = 0,0001:\n\t\t- 0,0001 = t0w + s \\* dw\n\t\t- s = (0,0001 - t0w) / (dw)\n- Маємо коефіціенти для кожної площини, відповідно підставляємо потім коефіціент у рівнняня відрізка по відповідним координатам і отримуємо координати точки","x":402,"y":140,"width":756,"height":1337,"color":"#c800ff"}
	],
	"edges":[
		{"id":"6d5fd8f233d1a04b","fromNode":"868471de6aae3b30","fromSide":"right","toNode":"26f34083ddf58ae3","toSide":"left"},
		{"id":"718feabe976b4ec2","fromNode":"868471de6aae3b30","fromSide":"bottom","toNode":"0401ff003e1eaba4","toSide":"top"},
		{"id":"9f346475e1a5d247","fromNode":"3614d84f8d624a2e","fromSide":"left","toNode":"51e04ffa1862db7f","toSide":"left"},
		{"id":"4d53a9e9f00a2f91","fromNode":"51e04ffa1862db7f","fromSide":"left","toNode":"960699b89895c096","toSide":"left"},
		{"id":"93a490daf0459b40","fromNode":"960699b89895c096","fromSide":"left","toNode":"29b96f38edbb3253","toSide":"left"},
		{"id":"1bd43c9f0abff34f","fromNode":"960699b89895c096","fromSide":"left","toNode":"1bbe76861b79b98a","toSide":"left"}
	]
}